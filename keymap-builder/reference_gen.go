// Code generated by referencegen; DO NOT EDIT.

package main

import "fmt"

func (x Trans) Reference() string {
	return fmt.Sprintf("&%s", x.Name())
}

func (x Trans) Name() string {
	return "trans"
}

func (x Trans) Args() []string {
	return []string{ }
}

func (x Trans) Slots() int {
	var count int
	
	if count > 2 {
		panic("too many slots")
	}

	return count
}

func (x None) Reference() string {
	return fmt.Sprintf("&%s", x.Name())
}

func (x None) Name() string {
	return "none"
}

func (x None) Args() []string {
	return []string{ }
}

func (x None) Slots() int {
	var count int
	
	if count > 2 {
		panic("too many slots")
	}

	return count
}

func (x Lt) Reference() string {
	return fmt.Sprintf("&%s %s %s", x.Name(), x.Layer, x.Tap)
}

func (x Lt) Name() string {
	return "lt"
}

func (x Lt) Args() []string {
	return []string{ fmt.Sprintf("%s", x.Layer), fmt.Sprintf("%s", x.Tap), }
}

func (x Lt) Slots() int {
	var count int
	
	var zeroLayer LayerIndex
	if zeroLayer == x.Layer {
		count++
	}
	
	var zeroTap KeyCode
	if zeroTap == x.Tap {
		count++
	}
	
	if count > 2 {
		panic("too many slots")
	}

	return count
}

func (x To) Reference() string {
	return fmt.Sprintf("&%s %s", x.Name(), x.Layer)
}

func (x To) Name() string {
	return "to"
}

func (x To) Args() []string {
	return []string{ fmt.Sprintf("%s", x.Layer), }
}

func (x To) Slots() int {
	var count int
	
	var zeroLayer LayerIndex
	if zeroLayer == x.Layer {
		count++
	}
	
	if count > 2 {
		panic("too many slots")
	}

	return count
}

func (x Mo) Reference() string {
	return fmt.Sprintf("&%s %s", x.Name(), x.Layer)
}

func (x Mo) Name() string {
	return "mo"
}

func (x Mo) Args() []string {
	return []string{ fmt.Sprintf("%s", x.Layer), }
}

func (x Mo) Slots() int {
	var count int
	
	var zeroLayer LayerIndex
	if zeroLayer == x.Layer {
		count++
	}
	
	if count > 2 {
		panic("too many slots")
	}

	return count
}

func (x Mt) Reference() string {
	return fmt.Sprintf("&%s %s %s", x.Name(), x.Hold, x.Tap)
}

func (x Mt) Name() string {
	return "mt"
}

func (x Mt) Args() []string {
	return []string{ fmt.Sprintf("%s", x.Hold), fmt.Sprintf("%s", x.Tap), }
}

func (x Mt) Slots() int {
	var count int
	
	var zeroHold KeyCode
	if zeroHold == x.Hold {
		count++
	}
	
	var zeroTap KeyCode
	if zeroTap == x.Tap {
		count++
	}
	
	if count > 2 {
		panic("too many slots")
	}

	return count
}

func (x Kp) Reference() string {
	return fmt.Sprintf("&%s %s", x.Name(), x.Tap)
}

func (x Kp) Name() string {
	return "kp"
}

func (x Kp) Args() []string {
	return []string{ fmt.Sprintf("%s", x.Tap), }
}

func (x Kp) Slots() int {
	var count int
	
	var zeroTap KeyCode
	if zeroTap == x.Tap {
		count++
	}
	
	if count > 2 {
		panic("too many slots")
	}

	return count
}

func (x KpKp) Reference() string {
	return fmt.Sprintf("&%s %s %s", x.Name(), x.Hold, x.Tap)
}

func (x KpKp) Name() string {
	return "kpkp"
}

func (x KpKp) Args() []string {
	return []string{ fmt.Sprintf("%s", x.Hold), fmt.Sprintf("%s", x.Tap), }
}

func (x KpKp) Slots() int {
	var count int
	
	var zeroHold KeyCode
	if zeroHold == x.Hold {
		count++
	}
	
	var zeroTap KeyCode
	if zeroTap == x.Tap {
		count++
	}
	
	if count > 2 {
		panic("too many slots")
	}

	return count
}

func (x MKp) Reference() string {
	return fmt.Sprintf("&%s %s", x.Name(), x.Tap)
}

func (x MKp) Name() string {
	return "mkp"
}

func (x MKp) Args() []string {
	return []string{ fmt.Sprintf("%s", x.Tap), }
}

func (x MKp) Slots() int {
	var count int
	
	var zeroTap KeyCode
	if zeroTap == x.Tap {
		count++
	}
	
	if count > 2 {
		panic("too many slots")
	}

	return count
}

func (x Rmt) Reference() string {
	return fmt.Sprintf("&%s %s %s", x.Name(), x.Hold, x.Tap)
}

func (x Rmt) Name() string {
	return "rmt"
}

func (x Rmt) Args() []string {
	return []string{ fmt.Sprintf("%s", x.Hold), fmt.Sprintf("%s", x.Tap), }
}

func (x Rmt) Slots() int {
	var count int
	
	var zeroHold KeyCode
	if zeroHold == x.Hold {
		count++
	}
	
	var zeroTap KeyCode
	if zeroTap == x.Tap {
		count++
	}
	
	if count > 2 {
		panic("too many slots")
	}

	return count
}
